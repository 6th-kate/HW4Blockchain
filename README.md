# HW4Blockchain
Homework #4 of smart-contracts development course

## Контрольные вопросы

### 1. В чём особенность смарт-контрактов без конструктора? 
Если в смарт-контракте не объявлен конструктор, дефолтный конструктор без параметров создается компилятором. Тогда при создании контракта все state-переменные инициализируются своими дефолтными значениями.

### 2. Чем отличается тип смарт-контракта library от типа contract?
Library-контракт - это смарт-контракт, сделанный специально для переиспользования кода - методы из него могут вызываться другими контрактами, и это значительно сокращает необходимое количество газа - тот же самый код library могут использовать много других контрактов. 

У library есть следующие ограничения:

- Не имеют хранилища (поэтому не могут иметь не константные state-переменные)
- Не могут хранить эфир (поэтому не могут иметь fallback-функцию)
- Не могут иметь payable-функции (поскольку не могут содержать эфир, отправить эфир тоже нельзя)
- Не могут наследоваться или быть уноследованными
- Не поддерживают уничтожение (с версии 0.4.20)

### 3. Какие типы памяти существуют в EVM?
Хранилище
Хранилище - это область памяти, хранящая постоянные данные контракта, такие как state-переменные. Хранилище - это словарь, который содержит пары из 256-битных слов к 256-битным словам. Данные хранилища потребляют много газа, потому что они записываются в блокчейн, поэтому их стоит использовать только для необходимых данных, например, баланса. Хранит state-переменные.

Память
Память - это данные, храняющиеся в видеть массива байтов, который существует только во время вызова функции. Каждый вызоы функции начинается с пустого массива памяти. Память - это изменчивые данные, которые не хранятся в блокчейне, поэтому они не потребляют много газа, поэтому память используется для непостоянных данных. Хранит локальные переменные.

Стэк
Стэк содержит небольшие локальные переменные. Его максимальный размер - 1024 элемента-слов размером 256 бита, следовательно, его максимальный размер - 1024 * 256 битв(262,144бита). Если место в стэке кончилось, выполнение контракта прервется. EVM позволяет изменять стэк вручную с помощью специальных функций, например, POP, PUSH, DUP(duplicate), и SWAP. Хранит локальные переменные.

### 4. Зачем нужен ABI?
ABI (Application Binary Interface, бинарный интерфейс приложения) - как и API, это интерфейс, позволяющий общаться двум программным модулям. ABI представляет собой закодированный в формате JSON программный интерфейс, делая его читаемым как для машин, так и для людей. Он содержит имена и типы функций, их входных и выходных параметров, а также сведения об изменчивости состояний (view, pure).

### 5. Зачем нужны вставки assembly в смарт-контакт?
Вставки assembly в контрактах нужны для взаимодействия с EVM на низком уровне. Они позволяют писать код на Yul и выполнять низкоуровневые операции на близком к машинному уровне, например, использовать указанные в вопросе #3 в информации про стэк (POP, PUSH, DUP(duplicate), и SWAP) функции, то есть вручную взаимодействовать с памятью. Код из вставок assembly является небезопасным, так как игнорирует некоторые проверки, однако он позволяет более точно оперировать машинными ресурсами.

### 6. Зачем нужен тип msg, tx, block?
msg, txt и block - это специальные глобальные переменные, позволяющие получить информацию о блокчейне, контрактах, а также используются для исполнения математических и криптографических функций.

msg - Глобальная переменная, содержащая информацию о текущем внешнем вызове функции. 
tx - Глобальная переменная, содержащая информацию о текущей транзакции. 
block - Глобальная переменная, содержащая информацию о текущем блоке.

### 7. Как можно задать случайное значение в смарт-контракт?
Блокчейн - детерминированная система, которая не позволяет случайностей, потому что логика блокчейна подчиняется строгим правилам, определяющим, что одни и те же операции над одними и теми же данными всегда приводят к одному и тому же результату. Поэтому блокчейн не позволяет сгенерировать по-настоящему случайного числа, однако возможно создать пседорандомное значение.
Псевдорандомные значения можно получить, например, используя информацию о текущем блоке - timestamp, number, difficulty. Свойства блока уязвимы, так как некоторые из них слишком статичны, а некоторые недобросовестный майнер может изменить, поэтому их использование создает уязвимость проекта.
